=== modified file 'models/01_modules.py'
--- models/01_modules.py	2010-01-14 19:31:18 +0000
+++ models/01_modules.py	2010-01-14 22:37:50 +0000
@@ -29,7 +29,7 @@
                 migrate=migrate)
 db[table].name.requires = [IS_NOT_EMPTY(), IS_NOT_IN_DB(db, '%s.name' % table)]
 db[table].name_nice.requires = [IS_NOT_EMPTY(), IS_NOT_IN_DB(db, '%s.name_nice' % table)]
-db[table].access.requires = IS_NULL_OR(IS_IN_DB(db, 'auth_group.id', '%(role)s', multiple=True)) # IS_ONE_OF ignores multiple!
+db[table].access.requires = IS_NULL_OR(IS_ONE_OF(db, 'auth_group.id', '%(role)s', multiple=True))
 db[table].priority.requires = [IS_NOT_EMPTY(), IS_NOT_IN_DB(db, '%s.priority' % table)]
 
 # Set to False in Production

=== modified file 'models/05_or.py'
--- models/05_or.py	2010-01-14 21:17:44 +0000
+++ models/05_or.py	2010-01-14 23:57:31 +0000
@@ -36,10 +36,19 @@
 msg_list_empty = T('No Sectors currently registered')
 s3.crud_strings[table] = Storage(title_create=title_create,title_display=title_display,title_list=title_list,title_update=title_update,title_search=title_search,subtitle_create=subtitle_create,subtitle_list=subtitle_list,label_list_button=label_list_button,label_create_button=label_create_button,msg_record_created=msg_record_created,msg_record_modified=msg_record_modified,msg_record_deleted=msg_record_deleted,msg_list_empty=msg_list_empty)
 # Reusable field for other tables to reference
+def sector_represent(sector_ids):
+    if not sector_ids:
+        return "None"
+    elif "|" in str(sector_ids):
+        sectors = [db(db.or_sector.id==id).select()[0].name for id in sector_ids.split('|') if id]
+        return ", ".join(sectors)
+    else:
+        return [db(db.or_sector.id==sector_ids).select()[0].name]
+
 sector_id = SQLTable(None, 'sector_id',
-            Field('sector_id', db.or_sector,
-                requires = IS_NULL_OR(IS_IN_DB(db, 'or_sector.id', 'or_sector.name', multiple=True)),
-                represent = lambda id: (id and [db(db.or_sector.id==id).select()[0].name] or ["None"])[0],
+            Field('sector_id',
+                requires = IS_NULL_OR(IS_ONE_OF(db, 'or_sector.id', '%(name)s', multiple=True)),
+                represent = sector_represent,
                 label = T('Sector'),
                 comment = DIV(A(ADD_ORGANISATION, _class='thickbox', _href=URL(r=request, c='or', f='sector', args='create', vars=dict(format='popup', KeepThis='true'))+"&TB_iframe=true", _target='top', _title=ADD_ORGANISATION), A(SPAN("[Help]"), _class="tooltip", _title=T("Add Sector|The Sector(s) this organisation works in. Multiple values can be selected by holding down the 'Control' key"))),
                 ondelete = 'RESTRICT'

=== modified file 'modules/validators.py'
--- modules/validators.py	2009-12-15 11:51:35 +0000
+++ modules/validators.py	2010-01-15 00:11:58 +0000
@@ -15,6 +15,7 @@
 
 import time
 import uuid
+import re
 from datetime import datetime, timedelta
 from gluon.validators import Validator, IS_MATCH, IS_NOT_IN_DB
 
@@ -148,7 +149,7 @@
 
         self.error_message = error_message
 
-        self.multiple = False # ignore multiple
+        self.multiple = multiple
 
         if hasattr(dbset, 'define_table'):
             self.dbset = dbset()
@@ -201,16 +202,32 @@
         try:
             _table = self.dbset._db[self.ktable]
 
-            query = (_table[self.kfield]==value)
-
-            if 'deleted' in _table:
-                query = (_table['deleted']==False) & query
-
+            if self.multiple:
+                values = re.compile("[\w\-:]+").findall(str(value))
+            else:
+                values = [value]
+
+            deleted_q = ('deleted' in _table) and (_table['deleted']==False) or False
+            
+            filter_opts_q = False
             if self.filterby and self.filterby in _table:
                 if self.filter_opts:
-                    query = (_table[self.filterby].belongs(self.filter_opts)) & query
-
-            if self.dbset(query).count():
+                    filter_opts_q = _table[self.filterby].belongs(self.filter_opts)
+
+            for v in values:
+
+                query = (_table[self.kfield]==v)
+                if deleted_q != False:
+                    query = deleted_q & query
+                if filter_opts_q != False:
+                    query = filter_opts_q & query
+
+                if self.dbset(query).count() < 1:
+                    return (value, self.error_message)                    
+
+            if self.multiple:
+                return ('|%s|' % '|'.join(values), None)                
+            else:
                 return (value, None)
 
         except:

